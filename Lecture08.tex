<<<<<<< HEAD
%!TEX root = InfoSec.tex
% Lecture 9: 6 October 2014
\sektion{8}{System Security}

\sidenote{
    \textbf{The Clipper Chip}\\
    This was a chip that implemented strong symmetric encryption; however it had a \textit{law enforcement access field} (LEAF), which gave the US government a backdoor to your data. Basically, if you wanted strong crypto you sacrificed privacy in the eyes of the government.\\

    The sender uses an 80 bit sessions key, a 32 bit unit key, and a 16 bit checksum value to create a unit key. Encrypt the unit key again and you get a family key (called a leaf) that is common to all chips.
}

\subsektion{Secure system design}
Secure components
\begin{itemize}
    \item in isolation (interaction only through approved interfaces)
    \item and access control (where access control = authentication; who is asking?)
    \item plus authorizaton (does the asker have the authority?)
\end{itemize}

\subsektion{Authorization}
\begin{enumerate}
    \item Access control matrix/list (like a bouncer with a list)
    \item Capabilities (like a physical key to open a lock)
\end{enumerate}

\textbf{Access control matrix}\\
SUBJECT wants to do VERB on OBJECT\\
- Are we going to allow it?\\

Policy: a set of allowed (subject, verb, object) triplets. So we have two questions now:
\begin{enumerate}
    \item How is policy set?
    \item How is policy enforced?\\
\end{enumerate}

\subsektion{Subjects and Objects}
The subject is a process and the object is some resource (file, open network connection, window, etc). We tend to use labels to simplify policy, and set policies based on these labels.

\begin{example}
Label a process with a userid, given that there is a limited set of users.
\end{example}

But things can get complicated
\begin{example}
Alice runs a program written by Bob. The program is a text editor and the file is code for Alice's startup.\\

How to label this program?
\begin{itemize}
    \item Treat as Alice: program can steal Alice's data
    \item Treat as Bob: Alice can read Bob's files
\end{itemize}

The common approah in OS (like Linux) is to setuid, where Bob decides if the program runs as himself or the invoker.
\end{example}

\subsektion{Storing the policy information}
\textbf{Access control matrix}\\
Matrix of subjects vs. objects with allowed verbs in each cell. The downfall with these is that you get a really really big matrix with lots of empty cells; it's inefficient. 

\textbf{Profiles}\\
For each user, they have access to their row of the matrix

\textbf{Access Control List (ACL)}\\
This is the most commont approach: For each objct, (subject, verb) pair, list whether it's allowed or not

\subsektion{Who sets up the ACL?}
\begin{itemize}
    \item Centralized, top-down policy

        Pro: Might be done by someone well-trained, might be required to be top-down (eg. medical and educational records)

        Con: Inflexible, slow (for example, might have to call a help desk)
    \item Decentralized

        Pro: super flexible

        Con: mistake-prone
    \item Mixed

        Owner can choose, within limits set by a centralized authority
\end{itemize}

\textbf{Groups}\\
Logically: a set of users or groups, such that you can give access to a group.

Advantages: Makes ACLs shorter, easier to understand. The group name may describe the reason for access in the system.

\textbf{Roles}\\
If a person ``wears several hats,'' you can have a role for each ``hat''. A user can step in/out of roles.

\subsektion{Traditional Unix file access}
A file belongs to one user or one group. The ACL for each operation contains some subset of (user, group, everyone).

setuserid bit: if executed, treat as file owner if setuid == true and treat as invoker if setuid == false.

\textbf{Capabilities}\\
``The bearer may do VERB on OBJECT''\\
By definition, if you have the capability, you can do the operation.
\begin{itemize}
    \item Cryptographic

    \begin{example}
    (VERB, OBJECT, PRF(k, VERB $||$ OBJECT)) where k is known only to the system. If you know the key k, you have the capability.
    \end{example}

    Pros: totally decentralized

    Cons: if capability leaks, everyone theoretically can get capability. Revocation is hard to do.

    \item OS tracking

    OS keeps track of which capabilities you have, you name them by index
\end{itemize}

\subsektion{Authorization Logics}
Formal logics, with \textbf{primitives} for PRINCIPALS (users, groups), OBJECTS, and PERMISSIONS and \textbf{rules} for delegation.

So, a user might present a bunch of true statements (``I am part of this group, Felton says that this group has access, etc.'') and the engine identifies if the logic implies that the user has permissions to access the file.

OR the system might require the user to come up with a proof that they have access privileges, in the form of a proof with formal logic.

=======
% Lecture 8: 10 October 2012
% System and software security - done with Crypto
\sektion{8}{Access control}
How you reason about and enforce rules about who's allowed to do what in the
system. 
\\
\\
Secure system design = secure components + isolation + access control.
\\
\\
This deals with authentication (Who is asking?), not authorization (Does that
person have permission?).
\\
\\
Two authorization approaches:
	\begin{itemize}
	\item access control matrix/list
	\item capabilities
	\end{itemize}

\begin{definition}{Trusted subsystem}\\
A program, with state, that is \underline{isolated} from
the rest of the world, and interacts via \underline{declared interfaces}
\end{definition}

Access control: SUBJECT wants to do VERB on OBECT. Okay?

Policy: a set of (S,V,O) triples that are allowed
\begin{itemize}
    \item How to determine policy? (\underline{should})
    \item How to enforce policy? (\underline{is})
\end{itemize}
One data structure: Access Control Matrix\\
\parbox[c]{5cm}{\makebox[5cm]{$\longleftarrow$ objects $\longrightarrow$}\\
\parbox[c]{1cm}{$\uparrow$\\
\begin{sideways}subjects\end{sideways}\\
$\downarrow$}
\makebox[.5cm]{}
\fbox{$V_1, V_2$}}

\subsektion{Subjects and labels}
\begin{itemize}
    \item subject = some process
    \item Object is some resource (file, open network connection, window)
    \item often, give labels to subjects and set policy based on labels
    e.g. label a process with a user id\\
    (+) reduces matrix size\\
    (+) easier to make policy based on labels\\
    (--) oversimplifies? Suppose: label = userid and means program is running
    ``for'' userid. Alice runs a program written by Bob (example: Alice uses a
        text editor written by Bob to edit Alice's secret file). What label?
    \begin{itemize}
        \item If treat as Alice: Bob's code can send Alice's secret data to Bob
        \item If treat as Bob: Alice can't edit her secret file, can read Bob's files
        \item If treat as Bob but special for this file: none of the labelling
        benefits
        \item If treat as intersection of privileges: get all the drawbacks
    \end{itemize}
    \item Common approach in OS (e.g. Linux): setuid bit
   	 \begin{itemize}
    	\item Bob decides whether program runs as himself or invoker
    	\end{itemize}
\end{itemize}
Store access control info:
\begin{itemize}
    \item as AC matrix - note that this will be very sparse
    \item as ``profiles'' - for each user, list of what subject can do (i.e. row of AC matrix)
    \item as Access Control List (ACL) - for each object, list of (Verb,
            Subject) pairs (who can do what to it). This is typically used
    because small and simple in practice. Often, ACL are stored along with object.
\end{itemize}
Who sets policy?
\begin{itemize}
    \item centralized (``mandatory'') - done by an authority

    (+) done by a well-trained person\\
    (+) might be required (ethical, legal, or contractual obligations)\\
    (--) inflexible, slow
    \item decentralized (``discretionary'') - each object has an
    \underline{owner}, owner set ACLs

    (+) flexible\\
    (--) every user makes security decisions (mistake-prone)
    
    \item mix - owner can choose, within limits set by centralized authority
\end{itemize}
Groups and Roles:\\
Group is a set of people with some logical basis; role is group with one
member\\
Advantages:
\begin{itemize}
    \item makes ACL smaller, easier to understand
    \item change in status naturally causes change in access to resources
    \item ACL encodes reason for access in system (i.e. why you have access)
\end{itemize}
Roles can be hidden temporarily, ``wearing different hats'' (useful for testing)

\subsektion{Traditional Unix File Access}
File belong to one user, one group. 
\\
\\ ACL for each operation contains subset of $\{\text{user}, \text{group}, \text{everyone}\}$. Every VERB requires 3 bits for each operation. 
\\
\\
Every file also has a setuserid bit. 
\begin{itemize}
	\item treat as file owner if setuid = true
	\ item treat as invoker if setuid = false
\end{itemize}

\subsektion{Capabilities}
A different approach to access control: controls access without identification,
like a physical key, ``the bearer has permission to do VERB on OBJECT.''

Sometimes make them revokable, but that's a pain to do in practice

Implementation: crpytographic
\begin{enumerate}
    \item system has a secret key $k$, capability = MAC($k$, verb || object)
    \item public-key: one party grant permission (makes digital signature),
    another party control access (makes sure handed valid capability - verifies
    signature)
\end{enumerate}
Implementation: OS table\\
OS stores a list of your capabilities; Alice makes a system call to give Bob
capabilities for a certain file (file descriptors used to say you've an open
file are an example)

Implementation: in a type-safe programming language (like Java), pointer to an
object is a capability
\\
\\
Tradeoffs:
\begin{itemize}
    \item cryptographic

    (+) totally decentralized \\
    (--) if capability leaks, big trouble\\
    want some kind of revocation, but hard to do
    
    \item OS table
    
    (+) can control flow of passage of capabilities\\
    (+) revocation is much easier\\
    (--) centralized, requires overhead, lack of flexibility, 
\end{itemize}

\subsektion{Logic-based authorization}
Define a formal logic, with primitives for
\begin{itemize}
    \item principals (e.g. users/groups)
    \item objects
    \item delegation
    \item time
\end{itemize}
To get access, submit a proof that you are authorized

Parties make statements by digital signing

System allows for great complexity in policies, but only need simple proof-
checking mechanism to make it work. But also need to work out a way to get
people able to write these statements, and deal with possible large proof size

Caveat: people don't actually use complicated access control mechanisms, and
usually just leave them as the defaults or make it visible to the whole world

Want to come up with a system which infers what the user wants from the way the
user behaves (best if not visible to user)
>>>>>>> 8e525b42b773087a879a1983645b17cc93ee0bb7
